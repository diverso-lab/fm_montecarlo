// Montecarlo class diagram
// ------------------

// Core
[FeatureModel{bg:gray}]
[Configuration{bg:gray}]

[FMGodelization|_fm_codes: dict;_fm_code_i: dict|__init__(fm: FeatureModel); godelization(config: Configuration): int;degodelization(config_number: int): list_Feature;_get_feature_model_codes(fm: FeatureModel): dict]
[FMGodelization]-[note: Use of a Godel function to assign a unique identifier number to each feature and configuration (for efficiency reasons storing configurations).{bg:wheat}]

// State
[<<abstract>>;State{bg:white}|find_succesors(): list_State; find_random_successor(): State; is_terminal(): bool; reward(): int; __hash__(): int; __eq__(s1: State, s2: State): bool]

// ConfigurationState
[ConfigurationState{bg:white}||__init__(fm: FeatureModel, features: list_Feature); is_valid(): bool; _get_undecided_mandatory_relations(): list_Relation; _get_undecided_optional_relations(): list_Relation; _get_undecided_features_for_relation(r: Relation): list_Feature; _get_successors_for_relation(r: Relation): list_ConfigurationState]
[ConfigurationState]-feature_model>[FeatureModel]
[ConfigurationState]-fm_godelization>[FMGodelization]
[Configuration]^[ConfigurationState]
[State]^[ConfigurationState]
[ConfigurationState]-[note: is_valid() uses a SAT solver to check validity considering also cross-tree constraints.{bg:wheat}]

// MonteCarlo
// ------------------
[<<abstract>>;MonteCarlo{bg:white}|choose(s: State): State; simulate(s: State): int; score(s: State): float]
[MonteCarlo]-[note: The score method returns the MC value for this state.{bg:wheat}]

[MonteCarloBasic{bg:white}|n_simulations: int; Q: dict(int); N: dict(int)]
[MonteCarloBasic{bg:white}]-[note: Q and N store the total reward and visit count, respectively, of each state.{bg:wheat}]
[MonteCarlo]^[MonteCarloBasic]
[MonteCarloBasic]Q->[State]
[MonteCarloBasic]N->[State]
